{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Recipes service</p> <ul> <li>DB: Database schema and considerations.</li> </ul>"},{"location":"db/","title":"Db","text":"<p>Database schema and considerations.</p>"},{"location":"db/#recipes.orm--tables","title":"Tables","text":""},{"location":"db/#recipes.orm--recipe","title":"<code>recipe</code>","text":"<code>id</code> `name e3t6 soup pvdl chips <p>Considerations</p> <p>A recipe represents the aggregate in this context but no real problem with multiple edits at the same time so no \"lock\" on the table.</p> <p>Elsewhere there might be a version column and a postgres database engine initialised with a repeatable read option.</p> <p>No problem with multiple edits because:</p> <ul> <li>Seems unlikely - in practice a recipe will be curated by a low number of users.</li> <li>Not business-critical - no-one, say, loses money if this happens.</li> </ul>"},{"location":"db/#recipes.orm--requirement","title":"<code>requirement</code>","text":"<code>recipe_id</code> <code>ingredient</code> <code>measurement</code> <code>quantity</code> pvdl potato units 2 e3t6 tomato grams 500 <p>Considerations</p> <p>There will be a lot of \"1 pinch of salt\" rows that may point to a <code>requirement</code> table such as:</p> <code>requirement_id</code> <code>ingredient</code> <code>measurement</code> <code>quantity</code> h92e potato units 2 dng3 tomato grams 500 <p>Combined with an association table between recipe and requirement.</p> <p><code>recipe_requirement</code></p> <code>recipe_id</code> <code>requirement_id</code> pvdl h92e e3t6 dng3 <p>Where multiple recipes can point to the same requirement.</p> <p>But constrast with, say, \"500 grams of flour\".</p> <p>There may be many many different requirements in the end. Especially considering the different measurements used around the world. Which would require converting all the measurements to some cardinal measurement.</p> <p>So save a join and take the hit on some duplicated data.</p>"},{"location":"repository/","title":"Repository","text":""},{"location":"repository/#recipes.repository.Repository","title":"<code>Repository</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Recipe repository protocol.</p> Source code in <code>src/recipes/repository.py</code> <pre><code>class Repository(Protocol):\n\"\"\"Recipe repository protocol.\"\"\"\n\n    session_factory: async_sessionmaker[AsyncSession] | None\n    session: AsyncSession\n\n    @classmethod\n    async def initialise(cls, cfg: config.Config) -&gt; None: ...\n\n    async def add(self, recipe: domain.Recipe) -&gt; domain.RecipeInDB: ...\n\n    async def get(self, recipe_id: str) -&gt; domain.RecipeInDB: ...\n\n    async def list(self) -&gt; list[domain.RecipeInDB]: ...\n</code></pre>"},{"location":"repository/#recipes.repository.SQLAlchemyRepository","title":"<code>SQLAlchemyRepository</code>","text":"<p>SQLAlchemy implementation of the Recipe repository protocol.</p> Source code in <code>src/recipes/repository.py</code> <pre><code>class SQLAlchemyRepository:\n\"\"\"SQLAlchemy implementation of the Recipe repository protocol.\"\"\"\n\n    engine: AsyncEngine | None = None\n    session_factory: async_sessionmaker[AsyncSession] | None = None\n\n    @classmethod\n    async def initialise(cls, cfg: config.Config) -&gt; None:\n        kwargs: dict[str, Any] = {}\n        if \"sqlite\" in cfg.database_url.lower():  # pragma: no cover\n            kwargs = kwargs | {\"check_same_thread\": False}\n        engine = create_async_engine(\n            cfg.database_url,\n            connect_args=kwargs,\n            echo=cfg.recipes_debug,\n        )\n\n        cls.engine = engine\n        cls.session_factory = async_sessionmaker(\n            autocommit=False, autoflush=False, bind=engine\n        )\n        if cfg.recipes_sql_alchemy_database_create:\n            async with cls.engine.begin() as conn:\n                await conn.run_sync(orm.Base.metadata.create_all)\n\n    def __init__(self) -&gt; None:\n        if self.session_factory is None:\n            raise RuntimeError(f\"{self.__class__.__name__} not initialised.\")\n        self.session = self.session_factory()\n\n    async def add(self, recipe: domain.Recipe) -&gt; domain.RecipeInDB:\n        recipe_in_db = domain.RecipeInDB.from_recipe(recipe)\n        orm_recipe = orm.Recipe.from_domain(recipe_in_db)\n        self.session.add(orm_recipe)\n        return recipe_in_db\n\n    async def get(self, recipe_id: str) -&gt; domain.RecipeInDB:\n        stmt = (\n            select(orm.Recipe)\n            .options(selectinload(orm.Recipe.requirements))\n            .where(orm.Recipe.id == recipe_id)\n        )\n        orm_recipe = await self.session.execute(stmt)\n        return domain.RecipeInDB.model_validate(orm_recipe.scalar_one())\n\n    async def list(self) -&gt; list[domain.RecipeInDB]:\n        stmt = select(orm.Recipe).options(selectinload(orm.Recipe.requirements))\n        orm_recipes = (await self.session.execute(stmt)).scalars().all()\n        return [domain.RecipeInDB.model_validate(o) for o in orm_recipes]\n</code></pre>"}]}